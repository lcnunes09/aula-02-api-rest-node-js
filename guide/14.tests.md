# Type of Tests

**Unit Tests:**
*Definition*: Unit tests are focused on testing individual components or functions in isolation. A unit test typically targets a small unit of code, like a function, method, or class.
*Purpose*: They help ensure that each part of your code works as expected and meets its specifications.
*Characteristics*: Unit tests are fast, isolated, and should not have external dependencies or interactions with databases, networks, or other services.

**Integration Tests:**
*Definition*: Integration tests focus on testing interactions between different components or modules of a system. They verify that different parts of your application work together as expected.
*Purpose*: They catch issues that might arise when different components are integrated, such as incorrect data exchange or communication problems.
*Characteristics*: Integration tests might involve multiple units, databases, external services, and other components. They are broader in scope compared to unit tests.

**End-to-End Tests (E2E Tests):**
*Definition*: End-to-end tests simulate real user scenarios by testing the entire application from start to finish. They mimic user interactions and verify the flow and behavior of the application.
*Purpose*: E2E tests help ensure that the entire application works as expected and that various parts of the system interact correctly.
*Characteristics*: E2E tests cover the full stack, including the frontend, backend, and often external services. They tend to be slower and more complex to set up compared to unit and integration tests.

Unit tests catch issues at a granular level, integration tests ensure components work together, and end-to-end tests verify the complete application's functionality.

In practice, a comprehensive testing strategy often involves a combination of these test types to ensure that your software is robust, reliable, and meets its requirements.

For this application, we are going to use **Vitest**.

## Install Vitest

Install as a development dependency, since the tests are never going to be run in Production:

```bash
npm i vitest -D
```

Create a `test` folder in the root of your application. This is where your tests are going to live.

To facilitate to run tests, create a new script on `package.json` file:

```json
"test": "vitest"
```

To run the tests - after implementing it:

```bash
npm run test
```

OR

```bash
npm test
```

## Supertest

Using Supertest with Fastify streamlines the process of testing your Fastify application's endpoints and ensures that your API behaves as expected. It provides a structured and efficient way to perform integration testing, helping you catch bugs and issues before they reach production.

### Install Supertest

Install as a development dependency, since the tests are never going to be run in Production:

```bash
npm i supertest -D
```

By using `supertest` means that you can run the test without running the application. With that said, it will be necessary to separate the app configuration and the code to run the server.

Note: Supertest is a library created in javascript, as is possible to see [here](https://www.npmjs.com/package/supertest). Because of that, it is also necessary to install @types/supertest.

```bash
npm i -D @types/supertest
```

## Create app.ts and update server.ts

Create `app.ts` file inside `src` folder.

On the `app.ts` file, add everything that is before to the `listen` method and **export** the *app*:

```js
import fastify from 'fastify'
import { transactionsRoutes } from './routes/transactions'
import cookie from '@fastify/cookie'

export const app = fastify()

app.register(cookie)

app.register(transactionsRoutes, {
    prefix: 'transactions',
})
```

At `server.ts` file, import *app* and *env* variables and add the `listen` method:

```js
import { app } from './app'
import { env } from './env' 

app.listen({
    port: env.PORT,
}).then(() => {
    console.log('HTTP Server Running')
})
```

Now, when importing the `app.ts` in the tests files, it won't be running the application, only the tests themselves.

## Create first test file

Create a file `transactions.spec.ts` inside test folder:

```js
import { test, beforeAll, afterAll } from 'vitest'
import request from 'supertest'
import { app } from '../src/app'

beforeAll(async () => {
    await app.ready()
})

afterAll(async () => {
    await app.close()
})

test('user can create a new transaction', async () => {
    const response = await request(app.server)
        .post('/transactions')
        .send({
            title: 'New transaction',
            amount: 5000,
            type: 'credit',
        })
        .expect(201)
})
```
